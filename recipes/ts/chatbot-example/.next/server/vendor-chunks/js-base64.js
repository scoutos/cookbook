/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-base64";
exports.ids = ["vendor-chunks/js-base64"];
exports.modules = {

/***/ "(ssr)/./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/***/ (function(module) {

eval("//\n// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!\n//\n;\n(function (global, factory) {\n     true\n        ? module.exports = factory()\n        : 0;\n}((typeof self !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n            : this), function () {\n    'use strict';\n    /**\n     *  base64.ts\n     *\n     *  Licensed under the BSD 3-Clause License.\n     *    http://opensource.org/licenses/BSD-3-Clause\n     *\n     *  References:\n     *    http://en.wikipedia.org/wiki/Base64\n     *\n     * @author Dan Kogai (https://github.com/dankogai)\n     */\n    var version = '3.7.2';\n    /**\n     * @deprecated use lowercase `version`.\n     */\n    var VERSION = version;\n    var _hasatob = typeof atob === 'function';\n    var _hasbtoa = typeof btoa === 'function';\n    var _hasBuffer = typeof Buffer === 'function';\n    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\n    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\n    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var b64chs = Array.prototype.slice.call(b64ch);\n    var b64tab = (function (a) {\n        var tab = {};\n        a.forEach(function (c, i) { return tab[c] = i; });\n        return tab;\n    })(b64chs);\n    var b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    var _fromCC = String.fromCharCode.bind(String);\n    var _U8Afrom = typeof Uint8Array.from === 'function'\n        ? Uint8Array.from.bind(Uint8Array)\n        : function (it, fn) {\n            if (fn === void 0) { fn = function (x) { return x; }; }\n            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\n        };\n    var _mkUriSafe = function (src) { return src\n        .replace(/=/g, '').replace(/[+\\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };\n    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\\+\\/]/g, ''); };\n    /**\n     * polyfill version of `btoa`\n     */\n    var btoaPolyfill = function (bin) {\n        // console.log('polyfilled');\n        var u32, c0, c1, c2, asc = '';\n        var pad = bin.length % 3;\n        for (var i = 0; i < bin.length;) {\n            if ((c0 = bin.charCodeAt(i++)) > 255 ||\n                (c1 = bin.charCodeAt(i++)) > 255 ||\n                (c2 = bin.charCodeAt(i++)) > 255)\n                throw new TypeError('invalid character found');\n            u32 = (c0 << 16) | (c1 << 8) | c2;\n            asc += b64chs[u32 >> 18 & 63]\n                + b64chs[u32 >> 12 & 63]\n                + b64chs[u32 >> 6 & 63]\n                + b64chs[u32 & 63];\n        }\n        return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    };\n    /**\n     * does what `window.btoa` of web browsers do.\n     * @param {String} bin binary string\n     * @returns {string} Base64-encoded string\n     */\n    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }\n        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }\n            : btoaPolyfill;\n    var _fromUint8Array = _hasBuffer\n        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }\n        : function (u8a) {\n            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n            var maxargs = 0x1000;\n            var strs = [];\n            for (var i = 0, l = u8a.length; i < l; i += maxargs) {\n                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n            }\n            return _btoa(strs.join(''));\n        };\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n     * @returns {string} Base64 string\n     */\n    var fromUint8Array = function (u8a, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const utob = (src: string) => unescape(encodeURIComponent(src));\n    // reverting good old fationed regexp\n    var cb_utob = function (c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                    + _fromCC(0x80 | (cc & 0x3f)))\n                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                        + _fromCC(0x80 | (cc & 0x3f)));\n        }\n        else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                + _fromCC(0x80 | (cc & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-8 string\n     * @returns {string} UTF-16 string\n     */\n    var utob = function (u) { return u.replace(re_utob, cb_utob); };\n    //\n    var _encode = _hasBuffer\n        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }\n        : _TE\n            ? function (s) { return _fromUint8Array(_TE.encode(s)); }\n            : function (s) { return _btoa(utob(s)); };\n    /**\n     * converts a UTF-8-encoded string to a Base64 string.\n     * @param {boolean} [urlsafe] if `true` make the result URL-safe\n     * @returns {string} Base64 string\n     */\n    var encode = function (src, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe\n            ? _mkUriSafe(_encode(src))\n            : _encode(src);\n    };\n    /**\n     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n     * @returns {string} Base64 string\n     */\n    var encodeURI = function (src) { return encode(src, true); };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const btou = (src: string) => decodeURIComponent(escape(src));\n    // reverting good old fationed regexp\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    var cb_btou = function (cccc) {\n        switch (cccc.length) {\n            case 4:\n                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                    | ((0x3f & cccc.charCodeAt(1)) << 12)\n                    | ((0x3f & cccc.charCodeAt(2)) << 6)\n                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n                return (_fromCC((offset >>> 10) + 0xD800)\n                    + _fromCC((offset & 0x3FF) + 0xDC00));\n            case 3:\n                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    | (0x3f & cccc.charCodeAt(2)));\n            default:\n                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                    | (0x3f & cccc.charCodeAt(1)));\n        }\n    };\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-16 string\n     * @returns {string} UTF-8 string\n     */\n    var btou = function (b) { return b.replace(re_btou, cb_btou); };\n    /**\n     * polyfill version of `atob`\n     */\n    var atobPolyfill = function (asc) {\n        // console.log('polyfilled');\n        asc = asc.replace(/\\s+/g, '');\n        if (!b64re.test(asc))\n            throw new TypeError('malformed base64.');\n        asc += '=='.slice(2 - (asc.length & 3));\n        var u24, bin = '', r1, r2;\n        for (var i = 0; i < asc.length;) {\n            u24 = b64tab[asc.charAt(i++)] << 18\n                | b64tab[asc.charAt(i++)] << 12\n                | (r1 = b64tab[asc.charAt(i++)]) << 6\n                | (r2 = b64tab[asc.charAt(i++)]);\n            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n        }\n        return bin;\n    };\n    /**\n     * does what `window.atob` of web browsers do.\n     * @param {String} asc Base64-encoded string\n     * @returns {string} binary string\n     */\n    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }\n        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }\n            : atobPolyfill;\n    //\n    var _toUint8Array = _hasBuffer\n        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }\n        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */\n    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };\n    //\n    var _decode = _hasBuffer\n        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }\n        : _TD\n            ? function (a) { return _TD.decode(_toUint8Array(a)); }\n            : function (a) { return btou(_atob(a)); };\n    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };\n    /**\n     * converts a Base64 string to a UTF-8 string.\n     * @param {String} src Base64 string.  Both normal and URL-safe are supported\n     * @returns {string} UTF-8 string\n     */\n    var decode = function (src) { return _decode(_unURI(src)); };\n    /**\n     * check if a value is a valid Base64 string\n     * @param {String} src a value to check\n      */\n    var isValid = function (src) {\n        if (typeof src !== 'string')\n            return false;\n        var s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n        return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n    };\n    //\n    var _noEnum = function (v) {\n        return {\n            value: v, enumerable: false, writable: true, configurable: true\n        };\n    };\n    /**\n     * extend String.prototype with relevant methods\n     */\n    var extendString = function () {\n        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };\n        _add('fromBase64', function () { return decode(this); });\n        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n        _add('toBase64URI', function () { return encode(this, true); });\n        _add('toBase64URL', function () { return encode(this, true); });\n        _add('toUint8Array', function () { return toUint8Array(this); });\n    };\n    /**\n     * extend Uint8Array.prototype with relevant methods\n     */\n    var extendUint8Array = function () {\n        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };\n        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n        _add('toBase64URI', function () { return fromUint8Array(this, true); });\n        _add('toBase64URL', function () { return fromUint8Array(this, true); });\n    };\n    /**\n     * extend Builtin prototypes with relevant methods\n     */\n    var extendBuiltins = function () {\n        extendString();\n        extendUint8Array();\n    };\n    var gBase64 = {\n        version: version,\n        VERSION: VERSION,\n        atob: _atob,\n        atobPolyfill: atobPolyfill,\n        btoa: _btoa,\n        btoaPolyfill: btoaPolyfill,\n        fromBase64: decode,\n        toBase64: encode,\n        encode: encode,\n        encodeURI: encodeURI,\n        encodeURL: encodeURI,\n        utob: utob,\n        btou: btou,\n        decode: decode,\n        isValid: isValid,\n        fromUint8Array: fromUint8Array,\n        toUint8Array: toUint8Array,\n        extendString: extendString,\n        extendUint8Array: extendUint8Array,\n        extendBuiltins: extendBuiltins\n    };\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });\n    return gBase64;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRTtBQUNBLFVBQVUsQ0FlTTtBQUNoQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLEVBQUUsb0JBQW9CLEVBQUUsc0JBQXNCLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNkRBQTZELCtCQUErQjtBQUM1RixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsNENBQTRDO0FBQzVDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxFQUFFLHdCQUF3QixFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSw0Q0FBNEM7QUFDNUMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUIseUNBQXlDLHlCQUF5QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsZ0NBQWdDLG1EQUFtRCwrQkFBK0I7QUFDbEg7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHlDQUF5QyxzQkFBc0I7QUFDL0QsOENBQThDLCtCQUErQjtBQUM3RSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLDBDQUEwQyw0QkFBNEI7QUFDdEUsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDhDQUE4Qyx1Q0FBdUM7QUFDckYsMENBQTBDLG9DQUFvQztBQUM5RSwwQ0FBMEMsb0NBQW9DO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsZ0RBQWdELHdDQUF3QztBQUN4RjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY291dG9zLXNkay10cy8uL25vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzP2M0OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vIFRISVMgRklMRSBJUyBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRCEgRE8gTk9UIEVESVQgQlkgSEFORCFcbi8vXG47XG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgICAgICA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgICAgICAgICAvLyBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTE5XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIHZlcnNpb24gZm9yIG5vQ29uZmxpY3QoKVxuICAgICAgICAgICAgICAgIHZhciBfQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICAgICAgICAgICAgICB2YXIgZ0Jhc2U2NCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICBnQmFzZTY0Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbC5CYXNlNjQgPSBfQmFzZTY0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ0Jhc2U2NDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWwuTWV0ZW9yKSB7IC8vIE1ldGVvci5qc1xuICAgICAgICAgICAgICAgICAgICBCYXNlNjQgPSBnQmFzZTY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gZ0Jhc2U2NDtcbiAgICAgICAgICAgIH0pKCk7XG59KCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG4gICAgICAgICAgICA6IHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqICBiYXNlNjQudHNcbiAgICAgKlxuICAgICAqICBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UuXG4gICAgICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICAgICAqXG4gICAgICogIFJlZmVyZW5jZXM6XG4gICAgICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGFuIEtvZ2FpIChodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkpXG4gICAgICovXG4gICAgdmFyIHZlcnNpb24gPSAnMy43LjInO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBsb3dlcmNhc2UgYHZlcnNpb25gLlxuICAgICAqL1xuICAgIHZhciBWRVJTSU9OID0gdmVyc2lvbjtcbiAgICB2YXIgX2hhc2F0b2IgPSB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgX2hhc2J0b2EgPSB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgX2hhc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIF9URCA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogdW5kZWZpbmVkO1xuICAgIHZhciBfVEUgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dEVuY29kZXIoKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgYjY0Y2ggPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIHZhciBiNjRjaHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiNjRjaCk7XG4gICAgdmFyIGI2NHRhYiA9IChmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgdGFiID0ge307XG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkgeyByZXR1cm4gdGFiW2NdID0gaTsgfSk7XG4gICAgICAgIHJldHVybiB0YWI7XG4gICAgfSkoYjY0Y2hzKTtcbiAgICB2YXIgYjY0cmUgPSAvXig/OltBLVphLXpcXGQrXFwvXXs0fSkqPyg/OltBLVphLXpcXGQrXFwvXXsyfSg/Oj09KT98W0EtWmEtelxcZCtcXC9dezN9PT8pPyQvO1xuICAgIHZhciBfZnJvbUNDID0gU3RyaW5nLmZyb21DaGFyQ29kZS5iaW5kKFN0cmluZyk7XG4gICAgdmFyIF9VOEFmcm9tID0gdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IFVpbnQ4QXJyYXkuZnJvbS5iaW5kKFVpbnQ4QXJyYXkpXG4gICAgICAgIDogZnVuY3Rpb24gKGl0LCBmbikge1xuICAgICAgICAgICAgaWYgKGZuID09PSB2b2lkIDApIHsgZm4gPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfTsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGl0LCAwKS5tYXAoZm4pKTtcbiAgICAgICAgfTtcbiAgICB2YXIgX21rVXJpU2FmZSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIHNyY1xuICAgICAgICAucmVwbGFjZSgvPS9nLCAnJykucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uIChtMCkgeyByZXR1cm4gbTAgPT0gJysnID8gJy0nIDogJ18nOyB9KTsgfTtcbiAgICB2YXIgX3RpZHlCNjQgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gcy5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpOyB9O1xuICAgIC8qKlxuICAgICAqIHBvbHlmaWxsIHZlcnNpb24gb2YgYGJ0b2FgXG4gICAgICovXG4gICAgdmFyIGJ0b2FQb2x5ZmlsbCA9IGZ1bmN0aW9uIChiaW4pIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICAgICAgdmFyIHUzMiwgYzAsIGMxLCBjMiwgYXNjID0gJyc7XG4gICAgICAgIHZhciBwYWQgPSBiaW4ubGVuZ3RoICUgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOykge1xuICAgICAgICAgICAgaWYgKChjMCA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAgICAgKGMxID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgICAgICAoYzIgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNoYXJhY3RlciBmb3VuZCcpO1xuICAgICAgICAgICAgdTMyID0gKGMwIDw8IDE2KSB8IChjMSA8PCA4KSB8IGMyO1xuICAgICAgICAgICAgYXNjICs9IGI2NGNoc1t1MzIgPj4gMTggJiA2M11cbiAgICAgICAgICAgICAgICArIGI2NGNoc1t1MzIgPj4gMTIgJiA2M11cbiAgICAgICAgICAgICAgICArIGI2NGNoc1t1MzIgPj4gNiAmIDYzXVxuICAgICAgICAgICAgICAgICsgYjY0Y2hzW3UzMiAmIDYzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkID8gYXNjLnNsaWNlKDAsIHBhZCAtIDMpICsgXCI9PT1cIi5zdWJzdHJpbmcocGFkKSA6IGFzYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGRvZXMgd2hhdCBgd2luZG93LmJ0b2FgIG9mIHdlYiBicm93c2VycyBkby5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmluIGJpbmFyeSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgX2J0b2EgPSBfaGFzYnRvYSA/IGZ1bmN0aW9uIChiaW4pIHsgcmV0dXJuIGJ0b2EoYmluKTsgfVxuICAgICAgICA6IF9oYXNCdWZmZXIgPyBmdW5jdGlvbiAoYmluKSB7IHJldHVybiBCdWZmZXIuZnJvbShiaW4sICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7IH1cbiAgICAgICAgICAgIDogYnRvYVBvbHlmaWxsO1xuICAgIHZhciBfZnJvbVVpbnQ4QXJyYXkgPSBfaGFzQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gKHU4YSkgeyByZXR1cm4gQnVmZmVyLmZyb20odThhKS50b1N0cmluZygnYmFzZTY0Jyk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAodThhKSB7XG4gICAgICAgICAgICAvLyBjZi4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI3MTAwMDEvaG93LXRvLWNvbnZlcnQtdWludDgtYXJyYXktdG8tYmFzZTY0LWVuY29kZWQtc3RyaW5nLzEyNzEzMzI2IzEyNzEzMzI2XG4gICAgICAgICAgICB2YXIgbWF4YXJncyA9IDB4MTAwMDtcbiAgICAgICAgICAgIHZhciBzdHJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHU4YS5sZW5ndGg7IGkgPCBsOyBpICs9IG1heGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBzdHJzLnB1c2goX2Zyb21DQy5hcHBseShudWxsLCB1OGEuc3ViYXJyYXkoaSwgaSArIG1heGFyZ3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2J0b2Eoc3Rycy5qb2luKCcnKSk7XG4gICAgICAgIH07XG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cmxzYWZlXSBVUkwtYW5kLWZpbGVuYW1lLXNhZmUgYSBsYSBSRkM0NjQ4IMKnNVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZnJvbVVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAodThhLCB1cmxzYWZlKSB7XG4gICAgICAgIGlmICh1cmxzYWZlID09PSB2b2lkIDApIHsgdXJsc2FmZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB1cmxzYWZlID8gX21rVXJpU2FmZShfZnJvbVVpbnQ4QXJyYXkodThhKSkgOiBfZnJvbVVpbnQ4QXJyYXkodThhKTtcbiAgICB9O1xuICAgIC8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuICAgIC8vIGNvbnN0IHV0b2IgPSAoc3JjOiBzdHJpbmcpID0+IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzcmMpKTtcbiAgICAvLyByZXZlcnRpbmcgZ29vZCBvbGQgZmF0aW9uZWQgcmVnZXhwXG4gICAgdmFyIGNiX3V0b2IgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gY2MgPCAweDgwID8gY1xuICAgICAgICAgICAgICAgIDogY2MgPCAweDgwMCA/IChfZnJvbUNDKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICAgICAgOiAoX2Zyb21DQygweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDApIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICAgICAgKyAoYy5jaGFyQ29kZUF0KDEpIC0gMHhEQzAwKTtcbiAgICAgICAgICAgIHJldHVybiAoX2Zyb21DQygweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiAxMikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDYpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVfdXRvYiA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZGXXxbXlxceDAwLVxceDdGXS9nO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBVVEYtOCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVVEYtMTYgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIHV0b2IgPSBmdW5jdGlvbiAodSkgeyByZXR1cm4gdS5yZXBsYWNlKHJlX3V0b2IsIGNiX3V0b2IpOyB9O1xuICAgIC8vXG4gICAgdmFyIF9lbmNvZGUgPSBfaGFzQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKHMsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9XG4gICAgICAgIDogX1RFXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChzKSB7IHJldHVybiBfZnJvbVVpbnQ4QXJyYXkoX1RFLmVuY29kZShzKSk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9idG9hKHV0b2IocykpOyB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgVVRGLTgtZW5jb2RlZCBzdHJpbmcgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIGlmIGB0cnVlYCBtYWtlIHRoZSByZXN1bHQgVVJMLXNhZmVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzcmMsIHVybHNhZmUpIHtcbiAgICAgICAgaWYgKHVybHNhZmUgPT09IHZvaWQgMCkgeyB1cmxzYWZlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHVybHNhZmVcbiAgICAgICAgICAgID8gX21rVXJpU2FmZShfZW5jb2RlKHNyYykpXG4gICAgICAgICAgICA6IF9lbmNvZGUoc3JjKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgVVRGLTgtZW5jb2RlZCBzdHJpbmcgdG8gVVJMLXNhZmUgQmFzZTY0IFJGQzQ2NDggwqc1LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgZW5jb2RlVVJJID0gZnVuY3Rpb24gKHNyYykgeyByZXR1cm4gZW5jb2RlKHNyYywgdHJ1ZSk7IH07XG4gICAgLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4gICAgLy8gY29uc3QgYnRvdSA9IChzcmM6IHN0cmluZykgPT4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzcmMpKTtcbiAgICAvLyByZXZlcnRpbmcgZ29vZCBvbGQgZmF0aW9uZWQgcmVnZXhwXG4gICAgdmFyIHJlX2J0b3UgPSAvW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl18W1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn18W1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30vZztcbiAgICB2YXIgY2JfYnRvdSA9IGZ1bmN0aW9uIChjY2NjKSB7XG4gICAgICAgIHN3aXRjaCAoY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSwgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2Zyb21DQygob2Zmc2V0ID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgX2Zyb21DQygob2Zmc2V0ICYgMHgzRkYpICsgMHhEQzAwKSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcm9tQ0MoKCgweDBmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxMilcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcm9tQ0MoKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBVVEYtMTYgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGJ0b3UgPSBmdW5jdGlvbiAoYikgeyByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpOyB9O1xuICAgIC8qKlxuICAgICAqIHBvbHlmaWxsIHZlcnNpb24gb2YgYGF0b2JgXG4gICAgICovXG4gICAgdmFyIGF0b2JQb2x5ZmlsbCA9IGZ1bmN0aW9uIChhc2MpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICAgICAgYXNjID0gYXNjLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgICAgICBpZiAoIWI2NHJlLnRlc3QoYXNjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBiYXNlNjQuJyk7XG4gICAgICAgIGFzYyArPSAnPT0nLnNsaWNlKDIgLSAoYXNjLmxlbmd0aCAmIDMpKTtcbiAgICAgICAgdmFyIHUyNCwgYmluID0gJycsIHIxLCByMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc2MubGVuZ3RoOykge1xuICAgICAgICAgICAgdTI0ID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0gPDwgMThcbiAgICAgICAgICAgICAgICB8IGI2NHRhYlthc2MuY2hhckF0KGkrKyldIDw8IDEyXG4gICAgICAgICAgICAgICAgfCAocjEgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSkgPDwgNlxuICAgICAgICAgICAgICAgIHwgKHIyID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0pO1xuICAgICAgICAgICAgYmluICs9IHIxID09PSA2NCA/IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1KVxuICAgICAgICAgICAgICAgIDogcjIgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1KVxuICAgICAgICAgICAgICAgICAgICA6IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1LCB1MjQgPj4gOCAmIDI1NSwgdTI0ICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZG9lcyB3aGF0IGB3aW5kb3cuYXRvYmAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhc2MgQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gYmluYXJ5IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBfYXRvYiA9IF9oYXNhdG9iID8gZnVuY3Rpb24gKGFzYykgeyByZXR1cm4gYXRvYihfdGlkeUI2NChhc2MpKTsgfVxuICAgICAgICA6IF9oYXNCdWZmZXIgPyBmdW5jdGlvbiAoYXNjKSB7IHJldHVybiBCdWZmZXIuZnJvbShhc2MsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7IH1cbiAgICAgICAgICAgIDogYXRvYlBvbHlmaWxsO1xuICAgIC8vXG4gICAgdmFyIF90b1VpbnQ4QXJyYXkgPSBfaGFzQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF9VOEFmcm9tKEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKSk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX1U4QWZyb20oX2F0b2IoYSksIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNoYXJDb2RlQXQoMCk7IH0pOyB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gICAgICovXG4gICAgdmFyIHRvVWludDhBcnJheSA9IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdG9VaW50OEFycmF5KF91blVSSShhKSk7IH07XG4gICAgLy9cbiAgICB2YXIgX2RlY29kZSA9IF9oYXNCdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiAoYSkgeyByZXR1cm4gQnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGY4Jyk7IH1cbiAgICAgICAgOiBfVERcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF9URC5kZWNvZGUoX3RvVWludDhBcnJheShhKSk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGJ0b3UoX2F0b2IoYSkpOyB9O1xuICAgIHZhciBfdW5VUkkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX3RpZHlCNjQoYS5yZXBsYWNlKC9bLV9dL2csIGZ1bmN0aW9uIChtMCkgeyByZXR1cm4gbTAgPT0gJy0nID8gJysnIDogJy8nOyB9KSk7IH07XG4gICAgLyoqXG4gICAgICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVVRGLTggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgQmFzZTY0IHN0cmluZy4gIEJvdGggbm9ybWFsIGFuZCBVUkwtc2FmZSBhcmUgc3VwcG9ydGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIF9kZWNvZGUoX3VuVVJJKHNyYykpOyB9O1xuICAgIC8qKlxuICAgICAqIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB2YWxpZCBCYXNlNjQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBhIHZhbHVlIHRvIGNoZWNrXG4gICAgICAqL1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBzID0gc3JjLnJlcGxhY2UoL1xccysvZywgJycpLnJlcGxhY2UoLz17MCwyfSQvLCAnJyk7XG4gICAgICAgIHJldHVybiAhL1teXFxzMC05YS16QS1aXFwrL10vLnRlc3QocykgfHwgIS9bXlxcczAtOWEtekEtWlxcLV9dLy50ZXN0KHMpO1xuICAgIH07XG4gICAgLy9cbiAgICB2YXIgX25vRW51bSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICAgICAqL1xuICAgIHZhciBleHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYWRkID0gZnVuY3Rpb24gKG5hbWUsIGJvZHkpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCBuYW1lLCBfbm9FbnVtKGJvZHkpKTsgfTtcbiAgICAgICAgX2FkZCgnZnJvbUJhc2U2NCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZSh0aGlzKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB1cmxzYWZlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b1VpbnQ4QXJyYXknLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZXh0ZW5kIFVpbnQ4QXJyYXkucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICAgICAqL1xuICAgIHZhciBleHRlbmRVaW50OEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FkZCA9IGZ1bmN0aW9uIChuYW1lLCBib2R5KSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpOyB9O1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NCcsIGZ1bmN0aW9uICh1cmxzYWZlKSB7IHJldHVybiBmcm9tVWludDhBcnJheSh0aGlzLCB1cmxzYWZlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0VVJJJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdHJ1ZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4dGVuZCBCdWlsdGluIHByb3RvdHlwZXMgd2l0aCByZWxldmFudCBtZXRob2RzXG4gICAgICovXG4gICAgdmFyIGV4dGVuZEJ1aWx0aW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHRlbmRTdHJpbmcoKTtcbiAgICAgICAgZXh0ZW5kVWludDhBcnJheSgpO1xuICAgIH07XG4gICAgdmFyIGdCYXNlNjQgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIFZFUlNJT046IFZFUlNJT04sXG4gICAgICAgIGF0b2I6IF9hdG9iLFxuICAgICAgICBhdG9iUG9seWZpbGw6IGF0b2JQb2x5ZmlsbCxcbiAgICAgICAgYnRvYTogX2J0b2EsXG4gICAgICAgIGJ0b2FQb2x5ZmlsbDogYnRvYVBvbHlmaWxsLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgZW5jb2RlVVJMOiBlbmNvZGVVUkksXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGJ0b3U6IGJ0b3UsXG4gICAgICAgIGRlY29kZTogZGVjb2RlLFxuICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgICAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgICAgIHRvVWludDhBcnJheTogdG9VaW50OEFycmF5LFxuICAgICAgICBleHRlbmRTdHJpbmc6IGV4dGVuZFN0cmluZyxcbiAgICAgICAgZXh0ZW5kVWludDhBcnJheTogZXh0ZW5kVWludDhBcnJheSxcbiAgICAgICAgZXh0ZW5kQnVpbHRpbnM6IGV4dGVuZEJ1aWx0aW5zXG4gICAgfTtcbiAgICAvL1xuICAgIC8vIGV4cG9ydCBCYXNlNjQgdG8gdGhlIG5hbWVzcGFjZVxuICAgIC8vXG4gICAgLy8gRVM1IGlzIHlldCB0byBoYXZlIE9iamVjdC5hc3NpZ24oKSB0aGF0IG1heSBtYWtlIHRyYW5zcGlsZXJzIHVuaGFwcHkuXG4gICAgLy8gZ0Jhc2U2NC5CYXNlNjQgPSBPYmplY3QuYXNzaWduKHt9LCBnQmFzZTY0KTtcbiAgICBnQmFzZTY0LkJhc2U2NCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGdCYXNlNjQpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGdCYXNlNjQuQmFzZTY0W2tdID0gZ0Jhc2U2NFtrXTsgfSk7XG4gICAgcmV0dXJuIGdCYXNlNjQ7XG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/js-base64/base64.js\n");

/***/ })

};
;